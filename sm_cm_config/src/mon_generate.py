#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""generate the C source file for the MCU Mon I2C addresses and initialization calls"""

import os
import sys
import argparse
import datetime
import subprocess
from string import Template

import yaml

parser = argparse.ArgumentParser(description='Process YAML for MCU Mon.')
parser.add_argument('-v', '--verbose', action='store_true',
                    help='increase output verbosity')
parser.add_argument('-o', '--output', type=str, help='output file name',
                    default="MonI2C_addresses.c")
#this argument is required
parser.add_argument('input_files', metavar='file', type=str,
                    nargs='+', help='input yaml file names')

args = parser.parse_args()

if args.output and args.verbose:
    print('Output file name:', args.output)

addr_template = Template("{$reg_size, $page, $reg_address, $size, \"$name\","
                         " $mask, \"$units\", $type, get_${name}_mask, set_${name}_data}, ")
# output file names: header file and c source file
# make sure that the output file ends with .c. Print error message and exit if it doesn't
if not args.output.endswith(".c"):
    print(f"Output file name {args.output} does not end with .c")
    sys.exit(1)
source_fname = args.output
header_fname = args.output[:-2] + '.h'

# open output c source file for writing
def write_boilderplate(fout):
    """Write the boilerplate to the output file"""
    print(f"// This file is generated by {os.path.basename(sys.argv[0])}", file=fout)
    print(r"// Do not edit this file directly", file=fout)
    print(r"// Edit the yaml files in the data directory and run the script again", file=fout)
    print(r"// to re-generate this file", file=fout)
    print(r"//", file=fout)
    print(r"// This file contains the arrays of the i2c monitoring data", file=fout)
    print(r"// and the C calls to set and retrieve it", file=fout)
    # Print timestamp to output file
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"// Generated: {timestamp}", file=fout)
    print(r"//", file=fout)

with open(source_fname, 'w', encoding="ascii") as fout_source, \
        open(header_fname, 'w', encoding="ascii") as fout_header:
    write_boilderplate(fout_source)
    write_boilderplate(fout_header)
    print("#include \"stdint.h\"", file=fout_source)
    print("#include \"MonitorI2CTask.h\"", file=fout_source)
    print(f"#include \"{header_fname}\"", file=fout_source)

    # header file 
    print(r"#ifndef MON_I2C_ADDRESSES_H", file=fout_header)
    print(r"#define MON_I2C_ADDRESSES_H", file=fout_header)
    print("#include \"stdint.h\"", file=fout_header)


    with open(args.input_files[0], encoding="ascii") as f:

        # generate the list of registers to access
        print(r"struct sm_command_t sm_command_test[] = {", file=fout_source)
        data = yaml.load(f, Loader=yaml.FullLoader)
        config = data['config']
        for c in config:
            s = addr_template.substitute(c)
            print(s, file=fout_source)
        print(r"};", file=fout_source)

        # generate the arrays to store the data
        print(r"// Arrays to store the data", file=fout_source)
        for c in config:
            print(f"static uint16_t {c['name']}_data[NFIREFLIES] = {{0}};", file=fout_source)
        # generate access functions
        print(r"// Access functions", file=fout_source)
        for c in config:
            set_fcn_name = f"set_{c['name']}_data"
            # getter
            print(f"uint16_t get_{c['name']}_data(int which);", file=fout_header)
            print(f"uint16_t get_{c['name']}_data(int which) {{", file=fout_source)
            print(f"    return {c['name']}_data[which];", file=fout_source)
            print(r"}", file=fout_source)
            # setter
            print(f"void {set_fcn_name}(uint16_t data, int which);", file=fout_header)
            print(f"void {set_fcn_name}(uint16_t data, int which) {{", file=fout_source)
            print(f"        {c['name']}_data[which] = data;", file=fout_source)
            print(r"}", file=fout_source)
        # using the devices field, generate a function that returns a mask of the devices
        print(r"// Function to return a mask of the devices for each command", file=fout_source)
        for c in config:
            print(f"uint16_t get_{c['name']}_mask(void);", file=fout_header)
            print(f"uint16_t get_{c['name']}_mask(void) {{", file=fout_source)
            print(r"    return ", end="", file=fout_source)
            for d in c['devices']:
                print(f"DEVICE_{d} | ", end="", file=fout_source)
            print(r"0;", file=fout_source)
            print(r"}", file=fout_source)
        # closing header guard
        print(r"#endif// MON_I2C_ADDRESSES_H", file=fout_header)

# reformat the c file using clang-format
# -style=file:$HOME/src/apollo_cm_mcu/.clang-format
# if the clang-format fails, we just ignore it
try:
    r = subprocess.run(["clang-format", "-i", source_fname, header_fname], check=False)
    if r.returncode != 0 and args.verbose:
        print('clang-format failed')
    if args.verbose:
        print('clang-format complete')
except FileNotFoundError as e:
    if args.verbose:
        print(f"clang-format not found: {e}")
