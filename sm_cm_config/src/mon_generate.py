#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""generate the C source file for the MCU Mon I2C addresses and initialization calls"""

import os
import sys
import argparse
import datetime
import subprocess
from string import Template

import yaml

parser = argparse.ArgumentParser(description='Process YAML for MCU Mon.')
parser.add_argument('-v', '--verbose', action='store_true',
                    help='increase output verbosity')
parser.add_argument('-o', '--output', type=str, help='output file name',
                    default="MonI2C_addresses.c")
#this argument is required
parser.add_argument('input_files', metavar='file', type=str,
                    nargs='+', help='input yaml file names')

args = parser.parse_args()

if args.output and args.verbose:
    print('Output file name:', args.output)

addr_template = Template("{$reg_size, $page, $reg_address, $size, \"$name\","
                         " $mask, \"$units\", $type, }, ")

# open output c source file for writing
with open(args.output, 'w', encoding="ascii") as fout:
    print(f"// This file is generated by {os.path.basename(sys.argv[0])}", file=fout)
    print(r"// Do not edit this file directly", file=fout)
    print(r"// Edit the yaml files in the data directory and run the script again", file=fout)
    print(r"// to re-generate this file", file=fout)
    print(r"//", file=fout)
    print(r"// This file contains the arrays of the i2c monitoring data", file=fout)
    print(r"// and the C calls to set and retrieve it", file=fout)
    # Print timestamp to output file
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"// Generated: {timestamp}", file=fout)
    print(r"//", file=fout)
    print("#include \"stdint.h\"", file=fout)
    print("#include \"MonitorI2CTask.h\"", file=fout)

    with open(args.input_files[0], encoding="ascii") as f:

        # generate the list of registers to access
        print(r"struct sm_command_t sm_command_test[] = {", file=fout)
        data = yaml.load(f, Loader=yaml.FullLoader)
        config = data['config']
        for c in config:
            s = addr_template.substitute(c)
            print(s, file=fout)
            # print(f"{{{c['reg_size']},\"{c['name']}\"}},", file=fout)
        print(r"};", file=fout)

        # generate the arrays to store the data
        print(r"// Arrays to store the data", file=fout)
        for c in config:
            print(f"static uint16_t {c['name']}_data[NUM_ENTRIES] = {{0}};", file=fout)
        # generate access functions
        print(r"// Access functions", file=fout)
        for c in config:
            print(f"uint16_t get_{c['name']}_data(int which) {{", file=fout)
            print(f"    return {c['name']}_data[which];", file=fout)
            print(r"}", file=fout)
            print(f"void set_{c['name']}_data(uint16_t data, int which) {{", file=fout)
            print(f"        {c['name']}_data[which] = data;", file=fout)
            print(r"}", file=fout)
        # using the devices field, generate a function that returns a mask of the devices
        print(r"// Function to return a mask of the devices for each command", file=fout)
        for c in config:
            print(f"uint16_t get_{c['name']}_mask(void) {{", file=fout)
            print(r"    return ", end="", file=fout)
            for d in c['devices']:
                print(f"DEVICE_{d} | ", end="", file=fout)
            print(r"0;", file=fout)
            print(r"}", file=fout)
# reformat the c file using clang-format
# -style=file:$HOME/src/apollo_cm_mcu/.clang-format
# if the clang-format fails, we just ignore it
try:
    r = subprocess.run(["clang-format", "-i", args.output], check=False)
    if r.returncode != 0 and args.verbose:
        print('clang-format failed')
    if args.verbose:
        print('clang-format complete')
except FileNotFoundError as e:
    if args.verbose:
        print(f"clang-format not found: {e}")
