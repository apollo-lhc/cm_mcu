#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""generate the C source file for the MCU Mon I2C addresses and initialization calls"""

import os
import sys
import argparse
import datetime
import subprocess
import io
from string import Template

import yaml

def parse_args() -> argparse.Namespace:
    """Parse the command line arguments"""
    parser = argparse.ArgumentParser(description='Process YAML for MCU Mon.')
    parser.add_argument('-v', '--verbose', action='store_true',
                    help='increase output verbosity')
    parser.add_argument('-o', '--output', type=str, help='output file name',
                    default="MonI2C_addresses.c")
#this argument is required
    parser.add_argument('input_files', metavar='file', type=str,
                    nargs='+', help='input yaml file names')

    return parser.parse_args()

def write_boilderplate(fout: io.TextIOWrapper):
    """Write the boilerplate to the output file"""
    print(f"// This file is generated by {os.path.basename(sys.argv[0])}", file=fout)
    print(r"// Do not edit this file directly", file=fout)
    print(r"// Edit the yaml files in the data directory and run the script again", file=fout)
    print(r"// to re-generate this file", file=fout)
    print(r"//", file=fout)
    print(r"// This file contains the arrays of the i2c monitoring data", file=fout)
    print(r"// and the C calls to set and retrieve it", file=fout)
    # Print timestamp to output file
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"// Generated: {timestamp}", file=fout)
    print(r"//", file=fout)

#######################################
#
# parse the command line arguments
#
#######################################
args = parse_args()

if args.output and args.verbose:
    print('Output file name:', args.output)

# addr_template = Template("{$reg_size, $page, $reg_address, $size, \"$name\","
#                          " $mask, \"$units\", $type, get_${name}_mask, set_${name}_data}, ")
addr_template = Template("{$reg_size, $page, $reg_list, $size, \"$name\","
                         " $mask, \"$units\", $type, get_${name}_mask, set_${name}_data}, ")
# output file names: header file and c source file
# make sure that the output file ends with .c. Print error message and exit if it doesn't
if not args.output.endswith(".c"):
    print(f"Output file name {args.output} does not end with .c")
    sys.exit(1)
source_fname = args.output
header_fname = args.output[:-2] + '.h'

#######################################
#
# end of processing command line arguments
#
#######################################

# open output c source file for writing
with open(source_fname, 'w', encoding="ascii") as fout_source, \
        open(header_fname, 'w', encoding="ascii") as fout_header:
    write_boilderplate(fout_source)
    write_boilderplate(fout_header)
    print(f"#include \"{header_fname}\"", file=fout_source)
    #print("#include \"MonitorTaskI2C_new.h\"", file=fout_source)

    # header file
    print(r"#ifndef MON_I2C_ADDRESSES_H", file=fout_header)
    print(r"#define MON_I2C_ADDRESSES_H", file=fout_header)
    print("#include <stdint.h>", file=fout_header)
    print("#include \"MonitorTaskI2C_new.h\"", file=fout_header)
    print("#include \"FireflyUtils.h\"", file=fout_source)
    print("#include \"MonitorI2CTask.h\"", file=fout_source)


    with open(args.input_files[0], encoding="ascii") as f:

        # generate the list of registers to access
        # loop over devices first
        data = yaml.load(f, Loader=yaml.FullLoader)
        for d in data['devices']:
            ndev = d['ndevices']
            ndev_types = d['ndevice_types']
            prefix = d['prefix']
            config = d['config']
            ncommands = len(config)
            print(f"#define NCOMMANDS_{prefix} {ncommands}", file=fout_header)
            print(f"// {prefix} has {ndev} devices and {ncommands} commands", file=fout_source)
            print(f"#define {prefix}_NOT_COVERED (-1)", file=fout_source)
            print(f"struct i2c_reg_command_t sm_command_test_{prefix}[NCOMMANDS_{prefix}] = {{",
                  file=fout_source)
            print(f"extern struct i2c_reg_command_t sm_command_test_{prefix}[NCOMMANDS_{prefix}];",
                  file=fout_header)
            for c in config:
                reg_list = c['reg_address']
                #print(f"reg list is >{reg_list}<")
                # if reg_list is an integer, convert it to a list of ndev_types integers
                # this handles the case where all ndev types share the same address
                if isinstance(reg_list, int):
                    reg_list = [reg_list]*int(ndev_types)
                    #print(f"reg list is >{reg_list}<")
                reg_list_str = '{'
                for r in reg_list:
                    if r > 0:
                        reg_list_str += f"{r}, "
                    else:
                        reg_list_str += f"{prefix}_NOT_COVERED, "
                reg_list_str += "}"
                s = addr_template.substitute(c, reg_list=reg_list_str)
                print(s, file=fout_source)
            print(r"};", file=fout_source)

            # generate the arrays to store the data
            print(r"// Arrays to store the data", file=fout_source)
            for c in config:
                print(f"static uint16_t {c['name']}_data[{ndev}] = {{0}};", file=fout_source)
            # generate access functions
            print(r"// Access functions", file=fout_source)
            for c in config:
                set_fcn_name = f"set_{c['name']}_data"
                # getter
                print(f"uint16_t get_{c['name']}_data(int which);", file=fout_header)
                print(f"uint16_t get_{c['name']}_data(int which) {{", file=fout_source)
                print(f"    return {c['name']}_data[which];", file=fout_source)
                print(r"}", file=fout_source)
                # setter
                print(f"void {set_fcn_name}(uint16_t data, int which);", file=fout_header)
                print(f"void {set_fcn_name}(uint16_t data, int which) {{", file=fout_source)
                print(f"        {c['name']}_data[which] = data;", file=fout_source)
                print(r"}", file=fout_source)
            # using the devices field, generate a function that returns a mask of the devices
            print(r"// Function to return a mask of the devices for each command", file=fout_source)
            for c in config:
                print(f"uint16_t get_{c['name']}_mask(void);", file=fout_header)
                print(f"uint16_t get_{c['name']}_mask(void) {{", file=fout_source)
                print(r"    return ", end="", file=fout_source)
                for d in c['devicetypes']:
                    print(f"DEVICE_{d} | ", end="", file=fout_source)
                print(r"0;", file=fout_source)
                print(r"}", file=fout_source)
            # closing header guard
        print(r"#endif// MON_I2C_ADDRESSES_H", file=fout_header)

# reformat the c file using clang-format
# -style=file:$HOME/src/apollo_cm_mcu/.clang-format
# if the clang-format fails, we just ignore it
try:
    r = subprocess.run(["clang-format", "-i", source_fname, header_fname], check=False)
    if r.returncode != 0 and args.verbose:
        print('clang-format failed')
    if args.verbose:
        print('clang-format complete')
except FileNotFoundError as e:
    if args.verbose:
        print(f"clang-format not found: {e}")
