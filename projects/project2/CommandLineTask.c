/*
 * CommandLineTask.c
 *
 *  Created on: Apr 7, 2019
 *      Author: wittich
 */
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"

#include "FreeRTOS_CLI.h"

#include "string.h"

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"

#include "i2c_reg.h"

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

#define CLI_UART UART4_BASE

extern void
UARTSend(const uint32_t base, const uint8_t *pui8Buffer, uint32_t ui32Count);



static const uint8_t * const pcWelcomeMessage =
    (uint8_t*)"FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";

CLI_Command_Definition_t i2c_read_command = {
    .pcCommand="i2cr",
    .pcHelpString="read i2c register. three arguments",
    .pxCommandInterpreter = readI2Creg,
    3
};

void vCommandLineTask( void *pvParameters )
{
  uint8_t cRxedChar, cInputIndex = 0;
  BaseType_t xMoreDataToFollow;
  /* The input and output buffers are declared static to keep them off the stack. */
  static int8_t pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];


  // register the commands
  FreeRTOS_CLIRegisterCommand(&i2c_read_command);

  /* Send a welcome message to the user knows they are connected. */
  UARTSend( CLI_UART, pcWelcomeMessage, strlen( (const char*)pcWelcomeMessage ) );

  for( ;; )
    {
      /* This implementation reads a single character at a time.  Wait in the
        Blocked state until a character is received. */
      UARTSend( CLI_UART, &cRxedChar, sizeof( cRxedChar ) );

      if( cRxedChar == '\n' )
	{
	  /* A newline character was received, so the input command string is
            complete and can be processed.  Transmit a line separator, just to
            make the output easier to read. */
	  UARTSend( CLI_UART, (uint8_t*)"\r\n", strlen( "\r\n" ));

	  /* The command interpreter is called repeatedly until it returns
            pdFALSE.  See the "Implementing a command" documentation for an
            explanation of why this is. */
	  do
	    {
	      /* Send the command string to the command interpreter.  Any
                output generated by the command interpreter will be placed in the
                pcOutputString buffer. */
	      xMoreDataToFollow = FreeRTOS_CLIProcessCommand
		  (
		      (const char*)pcInputString,   /* The command string.*/
		      (char*)pcOutputString,  /* The output buffer. */
		      MAX_OUTPUT_LENGTH/* The size of the output buffer. */
		  );

	      /* Write the output generated by the command interpreter to the
                console. */
	      UARTSend( CLI_UART, (const unsigned char*)pcOutputString,
			strlen( (const char*)pcOutputString ) );

	    } while( xMoreDataToFollow != pdFALSE );

	  /* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready
            to receive the next command. */
	  cInputIndex = 0;
	  memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
	}
      else
	{
	  /* The if() clause performs the processing after a newline character
            is received.  This else clause performs the processing if any other
            character is received. */

	  if( cRxedChar == '\r' )
	    {
	      /* Ignore carriage returns. */
	    }
	  else if( cRxedChar == '\b' )
	    {
	      /* Backspace was pressed.  Erase the last character in the input
                buffer - if there are any. */
	      if( cInputIndex > 0 )
		{
		  cInputIndex--;
		  pcInputString[ cInputIndex ] = '\0';
		}
	    }
	  else
	    {
	      /* A character was entered.  It was not a new line, backspace
                or carriage return, so it is accepted as part of the input and
                placed into the input buffer.  When a \n is entered the complete
                string will be passed to the command interpreter. */
	      if( cInputIndex < MAX_INPUT_LENGTH )
		{
		  pcInputString[ cInputIndex ] = cRxedChar;
		  cInputIndex++;
		}
	    }
	}
    }
}
