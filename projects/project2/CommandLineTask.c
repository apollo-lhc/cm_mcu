/*
 * CommandLineTask.c
 *
 *  Created on: Apr 7, 2019
 *      Author: wittich
 */


#include "common/i2c_reg.h"
#include "common/uart.h"

#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"

#include "FreeRTOS_CLI.h"

#include "string.h"
#include <stdlib.h>

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"

#include "driverlib/uart.h"


#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

// sample commands from the demo project
void vRegisterSampleCLICommands( void );

// Ugly hack for now -- I don't understand how to reconcile these
// two parts of the FreeRTOS-Plus code w/o casts o plenty
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpointer-sign"
#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"

static BaseType_t readI2Creg1(char *m, size_t s, const char *mm)
{

	int8_t *p1, *p2, *p3;
	BaseType_t p1l, p2l, p3l;
  p1 = FreeRTOS_CLIGetParameter(mm, 1, &p1l);
  p2 = FreeRTOS_CLIGetParameter(mm, 2, &p2l);
  p3 = FreeRTOS_CLIGetParameter(mm, 3, &p3l);
  p1[p1l] = 0x00; // terminate strings
  p2[p2l] = 0x00; // terminate strings
  p3[p3l] = 0x00; // terminate strings

  BaseType_t i1, i2, i3;
  i1 = strtol(p1, NULL, 10);
  i2 = strtol(p2, NULL, 10);
  i3 = strtol(p3, NULL, 10);
  uint8_t data[10];
  if ( i3 > 10 ) i3 = 10;
  readI2Creg(I2C1_BASE, i1, i2, data, i3);
  // should actually do something here

	return pdFALSE;
}

#pragma GCC diagnostic pop


static const char * const pcWelcomeMessage =
		"FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";

CLI_Command_Definition_t i2c_read_command = {
		.pcCommand="i2cr",
		.pcHelpString="read i2c register. three arguments",
		.pxCommandInterpreter = readI2Creg1,
		3
};

void vCommandLineTask( void *pvParameters )
{
	uint8_t cRxedChar, cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static int8_t pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];


	// register the commands
	FreeRTOS_CLIRegisterCommand(&i2c_read_command);

	// register sample commands
	vRegisterSampleCLICommands();

	/* Send a welcome message to the user knows they are connected. */
	UARTPrint( CLI_UART, pcWelcomeMessage);

	for( ;; ) {
		/* This implementation reads a single character at a time.  Wait in the
        Blocked state until a character is received. */
		cRxedChar = UARTCharGet(CLI_UART);

		if( cRxedChar == '\n' ) {
			/* A newline character was received, so the input command string is
            complete and can be processed.  Transmit a line separator, just to
            make the output easier to read. */
			UARTPrint( CLI_UART, "\r\n");

			/* The command interpreter is called repeatedly until it returns
            pdFALSE.  See the "Implementing a command" documentation for an
            explanation of why this is. */
			do {
				/* Send the command string to the command interpreter.  Any
                output generated by the command interpreter will be placed in the
                pcOutputString buffer. */
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand
						(
								(const char*)pcInputString,   /* The command string.*/
								(char*)pcOutputString,  /* The output buffer. */
								MAX_OUTPUT_LENGTH/* The size of the output buffer. */
						);

				/* Write the output generated by the command interpreter to the
                console. */
				UARTPrint( CLI_UART, (char*)pcOutputString);

			} while( xMoreDataToFollow != pdFALSE );

			/* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready
            to receive the next command. */
			cInputIndex = 0;
			memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
		}
		else {
			/* The if() clause performs the processing after a newline character
            is received.  This else clause performs the processing if any other
            character is received. */

			if( cRxedChar == '\r' ) {
				/* Ignore carriage returns. */
			}
			else if( cRxedChar == '\b' ) {
				/* Backspace was pressed.  Erase the last character in the input
                buffer - if there are any. */
				if( cInputIndex > 0 ) {
					cInputIndex--;
					pcInputString[ cInputIndex ] = '\0';
				}
			}
			else {
				/* A character was entered.  It was not a new line, backspace
                or carriage return, so it is accepted as part of the input and
                placed into the input buffer.  When a \n is entered the complete
                string will be passed to the command interpreter. */
				if( cInputIndex < MAX_INPUT_LENGTH ) {
					pcInputString[ cInputIndex ] = cRxedChar;
					cInputIndex++;
				}
			}
		}
	}
}
